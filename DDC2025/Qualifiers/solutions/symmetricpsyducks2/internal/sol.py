from sage.all import GF
from Crypto.Util.number import long_to_bytes
from Crypto.Util.strxor import strxor
import requests

from Crypto.Cipher import AES
import json

import time


# Replace this with remote
remoteURL = "http://127.0.0.1:8000"


def decode_cookie(cookie, context = b'basicusercontext'):
    return 
    # # cookie = cookie.split(".")
    # nonce, ct, tag = cookie
    # cipher = AES.new(b'A'*16, AES.MODE_GCM, nonce = nonce)
    # cipher.update(context)
    # pt = cipher.decrypt_and_verify(ct,tag).decode()
    # print(pt)
    # cookie_dict = json.loads(pt)
    # return cookie_dict


def registerfullurl(urlfull):
    resp = requests.get(urlfull)
    nonce, ct, tag = resp.headers["Set-Cookie"].split("=")[1].split(";")[0].split(".")

    return bytes.fromhex(nonce), bytes.fromhex(ct), bytes.fromhex(tag)


def register(username, role):
    resp = requests.get(register_url.format(username, role))
    nonce, ct, tag = resp.headers["Set-Cookie"].split("=")[1].split(";")[0].split(".")
    return bytes.fromhex(nonce), bytes.fromhex(ct), bytes.fromhex(tag)




x = GF(2)["x"].gen()
gf2e = GF(2 ** 128, name="y", modulus=x ** 128 + x ** 7 + x ** 2 + x + 1)


# Converts an integer to a gf2e element, little endian.
def int_to_gf2e(n):
    return gf2e([(n >> i) & 1 for i in range(127, -1, -1)])


# Converts a gf2e element to an integer, little endian.
def gf2e_to_int(p):
    n = p.integer_representation()
    ans = 0
    for i in range(128):
        ans <<= 1
        ans |= ((n >> i) & 1)

    return ans


# Converts a gf2e element to bytes, little endian
def gf2e_to_bytes(s):
    return gf2e_to_int(s).to_bytes(16, byteorder="big")


# Converts bytes to a gf2e element, little endian
def bytes_to_gf2e(s):
    return int_to_gf2e(int.from_bytes(s, byteorder="big"))


# Reverse the ghash function applied to single block input, taking standard padding into account
def reverse(h, t):
    p = bytes_to_gf2e(t)

    p *= h**-1  # First inversion
    p += bytes_to_gf2e(b"\x00" * 8 + long_to_bytes(8 * 16, 8))  # ghash is by default padded with additional data and length of plaintext

    p *= h**-1  # Second inversion

    return gf2e_to_bytes(p)


# Calculates the GHASH polynomial.
def ghash(h, a, c):
    """
    Calculates the ghash for a given H, ciphertext and additional data
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :return: the ghashed value (gf2e element)
    """

    la = len(a)
    lc = len(c)
    p = gf2e(0)
    for i in range(la // 16):
        p += int_to_gf2e(int.from_bytes(a[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if la % 16 != 0:
        p += int_to_gf2e(int.from_bytes(a[-(la % 16):] + bytes(16 - la % 16), byteorder="big"))
        p *= h

    for i in range(lc // 16):
        p += int_to_gf2e(int.from_bytes(c[16 * i:16 * (i + 1)], byteorder="big"))
        p *= h

    if lc % 16 != 0:
        p += int_to_gf2e(int.from_bytes(c[-(lc % 16):] + bytes(16 - lc % 16), byteorder="big"))
        p *= h

    p += int_to_gf2e(((8 * la) << 64) | (8 * lc))
    p *= h
    return p


def recover_possible_auth_keys(a1, c1, t1, a2, c2, t2):
    """
    Recovers possible authentication keys from two messages encrypted with the same authentication key.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param a1: the associated data of the first message (bytes)
    :param c1: the ciphertext of the first message (bytes)
    :param t1: the authentication tag of the first message (bytes)
    :param a2: the associated data of the second message (bytes)
    :param c2: the ciphertext of the second message (bytes)
    :param t2: the authentication tag of the second message (bytes)
    :return: a generator generating possible authentication keys (gf2e element)
    """

    h = gf2e["h"].gen()
    p1 = ghash(h, a1, c1) + int_to_gf2e(int.from_bytes(t1, byteorder="big"))
    p2 = ghash(h, a2, c2) + int_to_gf2e(int.from_bytes(t2, byteorder="big"))

    res = []
    for h, _ in (p1 + p2).roots():
        res.append(h)
    
    return res


def forge_tag(h, a, c, t, target_a, target_c):
    """
    Forges an authentication tag for a target message given a message with a known tag.
    This method is best used with the authentication keys generated by the recover_possible_auth_keys method.
    More information: Joux A., "Authentication Failures in NIST version of GCM"
    :param h: the authentication key to use (gf2e element)
    :param a: the associated data of the message with the known tag (bytes)
    :param c: the ciphertext of the message with the known tag (bytes)
    :param t: the known authentication tag (bytes)
    :param target_a: the target associated data (bytes)
    :param target_c: the target ciphertext (bytes)
    :return: HF value to xor to tag (bytes), the forged authentication tag (bytes)
    """

    source_ghash = gf2e_to_int(ghash(h, a, c))
    target_ghash = gf2e_to_int(ghash(h, target_a, target_c))
    HF = source_ghash ^ int.from_bytes(t, byteorder="big")

    return HF.to_bytes(16, byteorder="big"), (HF ^ target_ghash).to_bytes(16, byteorder="big")








nonce, ct, tag = registerfullurl(remoteURL + "/register?username=user&?role=user")
nonce1, ct1, tag1 = registerfullurl(remoteURL + "/register?role=user")
nonce2, ct2, tag2 = registerfullurl(remoteURL + "/register?username=user")
# nonce3, ct3, tag3 = registerfullurl(remoteURL + "/registerSuperAdmin")

print("user role time")
print(nonce.hex())
print(ct.hex())
print(tag.hex())
print(decode_cookie([nonce, ct, tag]))
print("role time user")
print(nonce1.hex())
print(ct1.hex())
print(tag1.hex())
print(decode_cookie([nonce1, ct1, tag1]))
print("user time role")
print(nonce2.hex())
print(ct2.hex())
print(tag2.hex())
print(decode_cookie([nonce2, ct2, tag2]))


assert nonce == nonce1 and nonce1 == nonce2, "timing missed. rerun"

print("nonces hit, proceeding")

h = recover_possible_auth_keys(b'basicusercontext', ct, tag, b'basicusercontext', ct1, tag1)

print(h)

# second try, to get confirmation of H

# Sleeping one second
print("sleeping one second to move to next time slot")
time.sleep(1)

nonce, ct, tag = registerfullurl(remoteURL + "/register?username=user&role=user")
# timenow = int(time.time()) + 3600
nonce1, ct1, tag1 = registerfullurl(remoteURL + "/register?role=user")
nonce2, ct2, tag2 = registerfullurl(remoteURL + "/register?username=user")
noncelong, ctlong, taglong = registerfullurl(remoteURL + "/register?username=user0&role=user0")

print("user role time")
print(nonce.hex())
print(ct.hex())
print(tag.hex())
print(decode_cookie([nonce, ct, tag]))
print("role time user")
print(nonce1.hex())
print(ct1.hex())
print(tag1.hex())
print(decode_cookie([nonce1, ct1, tag1]))
print("user time role")
print(nonce2.hex())
print(ct2.hex())
print(tag2.hex())
print(decode_cookie([nonce2, ct2, tag2]))


assert nonce == nonce1 and nonce1 == nonce2, "timing missed. rerun"

print("nonces hit, proceeding")

h2 = recover_possible_auth_keys(b'basicusercontext', ct, tag, b'basicusercontext', ct1, tag1)


sharedkeys = []
for x in h:
    if x in h2:
        print("this value is in both")
        print(x)
        sharedkeys.append(x)


assert len(sharedkeys) == 1, 'failed to find shared keys'
H = sharedkeys[0]
nonce = nonce
# def forge_tag(h, a, c, t, target_a, target_c):


realcookie = decode_cookie([noncelong, ctlong, taglong])
print(realcookie)
# input("real cookie")
realjson =   b'{"username": "user0", "role": "user0", "expirytime": 1737083630}'
targetjson = b'{"username": "admin", "role": "admin", "expirytime": 1737083630}'

def xor(a,b):
    assert len(a) == len(b)
    res = b''
    for i in range(max(len(a), len(b))):
        res += bytes([a[i]^b[i]])
    return res


print(len(ctlong))
print(ctlong)
print(len(targetjson))
targetct = xor(xor(realjson, targetjson), ctlong)

_, admin_tag = forge_tag(H, b'basicusercontext', ctlong, taglong, b'basicusercontext', targetct)

print(targetct)
print(admin_tag)



print(decode_cookie([noncelong, targetct, admin_tag]))

resp = requests.get(remoteURL + "/viewadmin", cookies= {"permissions": f"{noncelong.hex()}.{targetct.hex()}.{admin_tag.hex()}"})
content = resp.content
with open("adminpsyduck.png", "w+b") as f:
    f.write(content)


######### recovering the admin secret
for i in range(5):
    noncenorm, ctnorm, tagnorm = registerfullurl(remoteURL + "/register")
    noncesuper, ctsuper, tagsuper = registerfullurl(remoteURL + "/registerSuperAdmin")
    if noncesuper == noncenorm:
        break
assert noncesuper == noncenorm, "nonce mismatch, timing off"
assert ctnorm == ctsuper, 'ct somehow differs'
assert tagnorm != tagsuper, 'tags shouldnt be the same'
print(ctnorm)
print(ctsuper)
print(len(ctnorm))
assert len(ctnorm) == 62

ctlen = 62

aadknowni = bytes_to_gf2e(b'basicusercontext')
# length of aad + ct
lenctad     = bytes_to_gf2e(long_to_bytes(8*16, 8) + long_to_bytes(8 * ctlen, 8))

tagnormi = bytes_to_gf2e(tagnorm)
ct1i  = bytes_to_gf2e(ctnorm[:16])
ct2i  = bytes_to_gf2e(ctnorm[16:32])
ct3i  = bytes_to_gf2e(ctnorm[32:48])
ct4i  = bytes_to_gf2e(ctnorm[48:64])

tagsuperi = bytes_to_gf2e(tagsuper)
# tag + lenctad*H + ct1 * H**2 + ct2*H**3 + ct3*H**4 + ct4*H**5 + aad*H**6
C = tagnormi + lenctad * H + ct1i * H**2 + ct2i * H**3 + ct3i * H**4 + ct4i * H**5 + aadknowni * H**6

print(C)

adminsecreth6 = C + tagsuperi + lenctad * H + ct1i * H**2 + ct2i * H**3 + ct3i * H**4 + ct4i * H**5
adminsecret = adminsecreth6 / (H**6)

print(adminsecret)
admin_secret = gf2e_to_bytes(adminsecret)
print(admin_secret)


# def forge_tag(h, a, c, t, target_a, target_c):

_, newtag = forge_tag(H, b'basicusercontext', targetct, admin_tag, admin_secret, targetct)
print(newtag)


asdf = decode_cookie([noncelong, targetct, newtag], admin_secret)

print(asdf)

# flag.png tag
noncectr = b'\x00'*12
payload = AES.new(admin_secret, AES.MODE_CTR, nonce=noncectr).encrypt(b'flag.png')
urlflag = remoteURL + "/viewsuperadmin?psyduck=" + noncectr.hex() + payload.hex()

print(urlflag)
resp = requests.get(urlflag, cookies= {"permissions": f"{noncelong.hex()}.{targetct.hex()}.{newtag.hex()}"})
content = resp.content
with open("flag.png", "w+b") as f:
    f.write(content)

